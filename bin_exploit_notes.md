# Linux Dynamic Workflow

## GDB
`gdb ./some_program`
- `disassemble main` # Analyze the control flow
- `break *main` # Set a break point at the main function
- `run` # run the program
- `info registers` # Display the register information at the current execution state
- `si` # step one instruction
- `ni` # step one instruction but DONT follow function calls
- `define <hook name>` # define a hook to run each time a break point is hit while debugging
- `x/s $register` # examine a register as a string

## Python Notes
- `python -c 'print "A"*(63)'` # print characters oneliner, useful for BOF
- `struct.pack("I",0xd34db33f)` # convert from "integer" avoid actually having to write out little endian hex

## Objdump
- `objdump -d some_program` # print disassembly
- `objdump -x some_program `# print headers

## Strace
`strace ./some_program` # Traces live execution through syscalls

## Ltrace
`ltrace ./some_program` # Traces live execution through library calls

## Radare (this is dynamic workflow, see static for info on common commands)
`r2 -d some_program`
- `ood <params>` # starts the program if you forgot the -d flag
- `s sym.main`
- `aaa`
- `pdf`
- `db 0xSOMEADDR` # Place a break point
- `VV`
- `:dc` # ":" command mode, like visual mode in VIM, "dc" execute program
- `s` # step instructions
- `Shift S` # step instructions do not follow functions
- `dr` # Display registers
- `dr rip=0xSOMEADDR` # set a value of a register
- `V!` # fancy visual mode for debugging, can show psuedo code, very helpful





# General Notes:
- XREF stands for cross reference
- Putting hex into a python REPL converts to dec
- Python conversion notes: int('0101', 2) converts binary to dec, bin(255) dec to bin, hex(123) dec to hex, struct.unpack("I", "ABCD") gets array of binary/raw data to convert to int from there you can convert to hex or binary
- ESP is your stack pointer...important as fuck...you jump here to get basic code execution for BOF
- "\xCC" sets a break point, can be useful for debugging an exploit flow in GDB
- Sample BOF python script: 
    `import struct
    overflow = "A"*80 # Adapt this to however much data is needed to overflow the buffer
    target_addr = struct.pack("I",0xd34db33f) #some address you want to write to, usually esp
    nops = "\x90"*100 # NOPS as many as ya need
    shellcode = <shellcode in hex here>
    print overflow+target_addr+nops+shellcode`
- Sample BOF ret2libc python script:
    `import struct
    overflow = "A"*80 # Adapt this to however much data is needed to overflow the buffer
    libc_addr = struct.pack("I",0xb7ecffb0) # In this example we use system()
    return_after_system = "AAAA" # Address to return to after libc call, AAAA is all that is needed for a system() call to a local shell. This is great to chain together libc calls
    bin_sh = struct.pack("I",0xb7fb63bf) # /bin/sh string to pass into system()
    print overflow+libc_addr+return_after_system+bin_sh`

# Static Workflow

## Radare
`r2 some_program`
- `aaa` # Automatically analyze and autoname functions
- `afl` # Print all functions that radare found
- `s` # seek location "s sym.main"
- `pdf` # print disassembly of current function
- `VV` # visual mode control graph
- `Shift R` # change colors of control graph/the whole setup
- `afvn some_var new_var` # rename variable in visual mode
