# Linux Dynamic Workflow

## GDB
`gdb ./some_program`
- `disassemble main` # Analyze the control flow
- `break *main` # Set a break point at the main function
- `run` # run the program
- `info registers` # Display the register information at the current execution state
- `si` # step one instruction
- `ni` # step one instruction but DONT follow function calls

## Objdump
- `objdump -d some_program` # print disassembly
- `objdump -x some_program `# print headers

## Strace
`strace ./some_program` # Traces live execution through syscalls

## Ltrace
`ltrace ./some_program` # Traces live execution through library calls

## Radare (this is dynamic workflow, see static for info on common commands)
`r2 -d some_program`
- `ood <params>` # starts the program if you forgot the -d flag
- `s sym.main`
- `aaa`
- `pdf`
- `db 0xSOMEADDR` # Place a break point
- `VV`
- `:dc` # ":" command mode, like visual mode in VIM, "dc" execute program
- `s` # step instructions
- `Shift S` # step instructions do not follow functions
- `dr` # Display registers
- `dr rip=0xSOMEADDR` # set a value of a register
- `V!` # fancy visual mode for debugging, can show psuedo code, very helpful





# General Notes:
- XREF stands for cross reference
- Putting hex into a python REPL converts to dec
- Python conversion notes: int('0101', 2) converts binary to dec, bin(255) dec to bin, hex(123) dec to hex, struct.unpack("I", "ABCD") gets array of binary/raw data to convert to int from there you can convert to hex or binary



# Static Workflow

## Radare
`r2 some_program`
- `aaa` # Automatically analyze and autoname functions
- `afl` # Print all functions that radare found
- `s` # seek location "s sym.main"
- `pdf` # print disassembly of current function
- `VV` # visual mode control graph
- `Shift R` # change colors of control graph/the whole setup
- `afvn some_var new_var` # rename variable in visual mode
