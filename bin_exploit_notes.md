# Linux Dynamic Workflow

## GDB
`gdb ./some_program`
- `disassemble main` # Analyze the control flow
- `break *main` # Set a break point at the main function
- `run` # run the program
- `info registers` # Display the register information at the current execution state
- `si` # step one instruction
- `ni` # step one instruction but DONT follow function calls

## Objdump
- `objdump -d some_program` # print disassembly
- `objdump -x some_program `# print headers

## Strace
`strace ./some_program` # Traces live execution through syscalls

## Ltrace
`ltrace ./some_program` # Traces live execution through library calls

## Radare (this is dynamic workflow, see static for info on common commands)
`r2 -d some_program`
- `ood <params>` # starts the program if you forgot the -d flag
- `s sym.main`
- `aaa`
- `pdf`
- `db 0xSOMEADDR` # Place a break point
- `VV`
- `:dc` # ":" command mode, like visual mode in VIM, "dc" execute program
- `s` # step instructions
- `Shift S` # step instructions do not follow functions




# General Notes:
- XREF stands for cross reference
- Putting hex into a python REPL converts to dec
- 

# Static Workflow

## Radare
`r2 some_program`
- `aaa` # Automatically analyze and autoname functions
- `afl` # Print all functions that radare found
- `s` # seek location "s sym.main"
- `pdf` # print disassembly of current function
- `VV` # visual mode control graph
- `Shift R` # change colors of control graph/the whole setup
